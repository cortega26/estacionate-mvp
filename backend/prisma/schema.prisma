// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Enums
enum DurationType {
  ELEVEN_HOURS @map("11h")
  TWENTY_THREE_HOURS @map("23h")
}

enum SpotStatus {
  available
  reserved
  blocked
}

enum BookingStatus {
  pending
  confirmed
  cancelled
  completed
  no_show
}

enum PaymentStatus {
  pending
  paid
  failed
  refunded
}

enum PaymentMethod {
  mercadopago
  fintoc
}

enum GatewayStatus {
  pending
  approved
  rejected
  cancelled
  refunded
}

enum BlocklistType {
  EMAIL
  PHONE
  RUT
  PLATE
  IP
}

// Models

model Building {
  id                String   @id @default(uuid())
  name              String   @db.VarChar(255)
  address           String
  adminCompany      String?  @map("admin_company") @db.VarChar(255)
  contactEmail      String   @map("contact_email") @db.VarChar(255)
  phone             String?  @db.VarChar(20)
  totalUnits        Int      @map("total_units")
  visitorSpotsCount Int      @default(0) @map("visitor_spots_count")
  timezone          String   @default("America/Santiago") @db.VarChar(50)
  createdAt         DateTime @default(now()) @map("created_at")
  updatedAt         DateTime @default(now()) @updatedAt @map("updated_at")
  platformCommissionRate Float    @default(0.10) @map("platform_commission_rate")
  softwareMonthlyFeeClp  Int      @default(0)    @map("software_monthly_fee_clp")

  salesRepId             String?  @map("sales_rep_id")
  salesRepCommissionRate Float    @default(0.05) @map("sales_rep_commission_rate")

  // Relations
  units        Unit[]
  visitorSpots VisitorSpot[]
  payouts      Payout[]
  users        User[]
  pricingRules PricingRule[] // Yield Management
  blocklistItems Blocklist[] // Security
  salesRep     User?   @relation("BuildingSalesRep", fields: [salesRepId], references: [id])
  salesRepCommissions SalesRepCommission[]

  @@index([salesRepId])
  @@map("buildings")
}

model Blocklist {
  id         String        @id @default(uuid())
  buildingId String?       @map("building_id") // Null = Global Ban
  type       BlocklistType
  value      String        @db.VarChar(255) // The email, plate, etc.
  reason     String?
  createdBy  String?       @map("created_by")
  
  createdAt  DateTime      @default(now()) @map("created_at")

  building   Building?     @relation(fields: [buildingId], references: [id], onDelete: Cascade)

  @@index([type, value])
  @@index([buildingId])
  @@map("blocklist")
}

model PricingRule {
  id         String   @id @default(uuid())
  buildingId String   @map("building_id")
  name       String   @db.VarChar(100)
  priority   Int      @default(1) // Higher priority overrides lower
  startDate  DateTime @map("start_date")
  endDate    DateTime @map("end_date")
  multiplier Float    // e.g., 2.0 = double price, 0.5 = half price
  
  isActive   Boolean  @default(true) @map("is_active")
  createdAt  DateTime @default(now()) @map("created_at")

  building   Building @relation(fields: [buildingId], references: [id], onDelete: Cascade)

  @@index([buildingId, isActive])
  @@index([startDate, endDate])
  @@map("pricing_rules")
}

model Unit {
  id         String   @id @default(uuid())
  buildingId String   @map("building_id")
  unitNumber String   @map("unit_number") @db.VarChar(10)
  floor      Int?
  isActive   Boolean  @default(true) @map("is_active")
  createdAt  DateTime @default(now()) @map("created_at")

  // Relations
  building  Building   @relation(fields: [buildingId], references: [id], onDelete: Cascade)
  residents Resident[]

  @@unique([buildingId, unitNumber])
  @@map("units")
}

model Resident {
  id               String    @id @default(uuid())
  unitId           String    @map("unit_id")
  email            String    @unique @db.VarChar(255)
  rut              String    @db.VarChar(255) // Encrypted (IV:Cipher) - removed @unique
  rutHash          String?   @unique @map("rut_hash") @db.VarChar(64) // Blind Index for lookups
  firstName        String    @map("first_name") @db.VarChar(100)
  lastName         String    @map("last_name") @db.VarChar(100)
  phone            String?   @db.VarChar(255) // Encrypted (IV:Cipher)
  isVerified       Boolean   @default(false) @map("is_verified")
  verifiedAt       DateTime? @map("verified_at")
  verificationCode String?   @map("verification_code") @db.VarChar(10)
  passwordHash     String?   @map("password_hash") @db.VarChar(255) // Added for MVP password login
  
  // Account Recovery
  resetToken          String?   @map("reset_token") @db.VarChar(255)
  resetTokenExpiresAt DateTime? @map("reset_token_expires_at")

  isActive         Boolean   @default(true) @map("is_active")

  // Rate Limiting
  failedLoginAttempts Int       @default(0) @map("failed_login_attempts")
  lockoutUntil        DateTime? @map("lockout_until")

  createdAt        DateTime  @default(now()) @map("created_at")

  // Relations
  unit     Unit      @relation(fields: [unitId], references: [id], onDelete: Restrict)
  bookings Booking[]

  @@map("residents")
}

model VisitorSpot {
  id          String   @id @default(uuid())
  buildingId  String   @map("building_id")
  spotNumber  String   @map("spot_number") @db.VarChar(10)
  description String?
  isActive    Boolean  @default(true) @map("is_active")
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @default(now()) @updatedAt @map("updated_at")

  // Relations
  building           Building            @relation(fields: [buildingId], references: [id], onDelete: Cascade)
  availabilityBlocks AvailabilityBlock[]

  @@unique([buildingId, spotNumber])
  @@index([buildingId])
  @@map("visitor_spots")
}

model AvailabilityBlock {
  id             String       @id @default(uuid())
  spotId         String       @map("spot_id")
  startDatetime  DateTime     @map("start_datetime")
  endDatetime    DateTime     @map("end_datetime")
  durationType   DurationType @map("duration_type")
  basePriceClp   Int          @map("base_price_clp")
  status         SpotStatus   @default(available)
  createdAt      DateTime     @default(now()) @map("created_at")
  updatedAt      DateTime     @default(now()) @updatedAt @map("updated_at")

  // Relations
  spot     VisitorSpot @relation(fields: [spotId], references: [id], onDelete: Cascade)
  bookings Booking[]

  @@map("availability_blocks")
  @@index([spotId, status])
  @@index([startDatetime, endDatetime])
  @@index([status, startDatetime]) // Optimized for "Find Available Spots" query
}

model Booking {
  id                  String        @id @default(uuid())
  residentId          String        @map("resident_id")
  availabilityBlockId String        @map("availability_block_id")
  visitorName         String        @map("visitor_name") @db.VarChar(255)
  visitorPhone        String?       @map("visitor_phone") @db.VarChar(20)
  vehiclePlate        String        @map("vehicle_plate") @db.VarChar(10)
  amountClp           Int           @map("amount_clp")
  commissionClp       Int           @map("commission_clp")
  status              BookingStatus @default(pending)
  paymentStatus       PaymentStatus @default(pending) @map("payment_status")
  confirmationCode    String        @unique @map("confirmation_code") @db.VarChar(10)
  specialInstructions String?       @map("special_instructions")
  createdAt           DateTime      @default(now()) @map("created_at")
  updatedAt           DateTime      @default(now()) @updatedAt @map("updated_at")

  // Relations
  resident          Resident          @relation(fields: [residentId], references: [id], onDelete: Restrict)
  availabilityBlock AvailabilityBlock @relation(fields: [availabilityBlockId], references: [id], onDelete: Restrict)
  payment           Payment?

  @@map("bookings")
  @@index([residentId])
  @@index([status])
  @@index([createdAt])
  @@index([availabilityBlockId])
}

model Payment {
  id                String        @id @default(uuid())
  bookingId         String        @unique @map("booking_id")
  externalPaymentId String?       @map("external_payment_id") @db.VarChar(255)
  paymentMethod     PaymentMethod? @map("payment_method")
  amountClp         Int           @map("amount_clp")
  status            GatewayStatus @default(pending)
  gatewayResponse   Json?         @map("gateway_response")
  processedAt       DateTime?     @map("processed_at")
  createdAt         DateTime      @default(now()) @map("created_at")

  // Relations
  booking Booking @relation(fields: [bookingId], references: [id], onDelete: Restrict)

  @@map("payments")
}

model Payout {
  id                    String    @id @default(uuid())
  buildingId            String    @map("building_id")
  periodStart           DateTime  @map("period_start") @db.Date
  periodEnd             DateTime  @map("period_end") @db.Date
  totalRevenueClp       Int       @map("total_revenue_clp")
  platformCommissionClp Int       @map("platform_commission_clp")
  buildingShareClp      Int       @map("building_share_clp")
  status                String    @default("calculated") @db.VarChar(20) // calculated, paid, disputed
  paidAt                DateTime? @map("paid_at")
  createdAt             DateTime  @default(now()) @map("created_at")

  // Relations
  building Building @relation(fields: [buildingId], references: [id], onDelete: Restrict)
  salesRepCommissions SalesRepCommission[]

  @@index([buildingId])
  @@index([status])
  @@index([createdAt])
  @@map("payouts")
}

enum Role {
  admin
  support
  building_admin
  concierge
  sales_rep
}

enum ActorType {
  HUMAN
  AGENT
  SYSTEM
}

model AuditLog {
  id          String    @id @default(uuid())
  actorId     String    @map("actor_id") // ID of User or Name of Agent
  actorType   ActorType @map("actor_type")
  action      String    @db.VarChar(255)
  entityId    String?   @map("entity_id")
  entityType  String?   @map("entity_type")
  metadata    Json?
  ipAddress   String?   @map("ip_address") @db.VarChar(45)
  userAgent   String?   @map("user_agent")
  occurredAt  DateTime  @default(now()) @map("occurred_at")

  @@map("audit_logs")
  @@index([actorId])
  @@index([action])
  @@index([occurredAt])
}

model SalesRepCommission {
  id          String   @id @default(uuid())
  salesRepId  String   @map("sales_rep_id")
  buildingId  String   @map("building_id")
  payoutId    String?  @map("payout_id")
  amountClp   Int      @map("amount_clp")
  status      String   @default("pending") // pending, paid
  periodStart DateTime @map("period_start")
  periodEnd   DateTime @map("period_end")
  createdAt   DateTime @default(now()) @map("created_at")

  salesRep    User     @relation(fields: [salesRepId], references: [id])
  building    Building @relation(fields: [buildingId], references: [id])
  payout      Payout?  @relation(fields: [payoutId], references: [id])
  
  @@map("sales_rep_commissions")
  @@index([salesRepId])
  @@unique([payoutId])
}

model User {
  id           String   @id @default(uuid())
  email        String   @unique @db.VarChar(255)
  phone        String?  @db.VarChar(255) // Encrypted (WhatsApp Recovery)
  passwordHash String   @map("password_hash") @db.VarChar(255)
  role         Role     @default(admin)
  buildingId   String?  @map("building_id")
  isActive     Boolean  @default(true) @map("is_active")

  // Account Recovery
  resetToken          String?   @map("reset_token") @db.VarChar(255)
  resetTokenExpiresAt DateTime? @map("reset_token_expires_at")

  // Rate Limiting
  failedLoginAttempts Int       @default(0) @map("failed_login_attempts")
  lockoutUntil        DateTime? @map("lockout_until")

  createdAt    DateTime @default(now()) @map("created_at")

  // Relations
  building Building? @relation(fields: [buildingId], references: [id])
  managedBuildings Building[] @relation("BuildingSalesRep")
  commissions      SalesRepCommission[]

  @@map("users")
  @@index([role])
  @@index([createdAt])
}
